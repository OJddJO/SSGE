name: Release new version
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release'
        required: true

permissions:
  contents: write

jobs:
  create_release:
    name: Create Release and upload assets
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    env:
      VERSION: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version || github.ref_name }}

    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create changelog from commits since latest tag
        id: make_changelog
        run: |
          set -euo pipefail
          # find latest tag (if any)
          LATEST_TAG=$(git describe --tags --abbrev=0)
          if [ -n "$LATEST_TAG" ]; then
            RANGE="${LATEST_TAG}..HEAD"
            HEADER="Changes since ${LATEST_TAG}:"
          else
            RANGE="HEAD"
            HEADER="All commits:"
          fi

          # get commit subject and author separated by |, preserve order, group by subject
          raw=$(git --no-pager log --pretty=format:'%s|%an' $RANGE || true)
          if [ -z "$raw" ]; then
            CHANGELOG="No changes"
          else
            CHANGELOG=$(printf '%s\n' "$raw" | awk -F'|' '
              {
                subj=$1
                auth=$2
                if (!(subj in seen)) { seen[subj]=1; order[++n]=subj; author[subj]=auth }
                count[subj]++
              }
              END {
                for (i=1;i<=n;i++) {
                  s=order[i]
                  printf "- %s (%s)", s, author[s]
                  if (count[s] > 1) printf " x%d", count[s]
                  printf "\n"
                }
              }')
          fi

          # output multiline changelog safely
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n\n' "${HEADER}" >> "$GITHUB_OUTPUT"
          printf '%s\n' "$CHANGELOG" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Create GitHub Release (API)
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ env.VERSION }}
          CHANGELOG: ${{ steps.make_changelog.outputs.changelog }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"
          JSON=$(jq -n --arg tag "${VERSION}" --arg name "${VERSION}" --arg body "${{steps.make_changelog.outputs.changelog}}" \
            '{ tag_name: $tag, name: $name, body: $body, draft: false, prerelease: false }')
          resp=$(curl -sSL -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" \
            -d "$JSON" "$API")
          echo "$resp" | jq . >/tmp/release_resp.json
          upload_url=$(jq -r .upload_url /tmp/release_resp.json | sed -e 's/{.*}//')
          echo "upload_url=$upload_url" >> "$GITHUB_OUTPUT"
        shell: bash

  build:
    name: Build and Package
    needs: create_release
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    env:
      VERSION: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version || github.ref_name }}

    steps:
      - uses: actions/checkout@v3

      - name: Set up build tools (Windows)
        if: runner.os == 'Windows'
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >
            mingw-w64-x86_64-toolchain
            make
            mingw-w64-x86_64-7zip

      - name: Set up build tools (Ubuntu)
        if: runner.os == 'Linux'
        run: sudo apt-get install build-essential libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev libsdl2-mixer-dev -yq

      - name: Build (Windows)
        if: runner.os == 'Windows'
        run: make
        shell: bash

      - name: Build (Ubuntu)
        if: runner.os == 'Linux'
        run: make
        shell: bash

      - name: Package assets (Windows)
        if: runner.os == 'Windows'
        run: |
          mkdir -p release
          rm -rf _windows/build/ _windows/build_static/
          (cd _windows && 7z a -tzip "../release/SSGE-${VERSION}-windows.zip" ./*)
          7z a -tzip "release/SSGE-${VERSION}-windows.zip" include README.md LICENSE
        shell: bash

      - name: Package assets (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          set -e
          mkdir -p release tmp_release
          rm -rf tmp_release/* _linux/build/ _linux/build_static/
          cp -a _linux/. tmp_release/
          cp -a include/ README.md LICENSE tmp_release/
          tar -czf "release/SSGE-${VERSION}-linux.tar.gz" -C tmp_release .
          rm -rf tmp_release
        shell: bash

      - name: Check release upload URL
        run: echo "Upload URL = ${{ needs.create_release.outputs.upload_url }}"

      - name: Upload release assets (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: ./release/SSGE-${VERSION}-windows.zip
          asset_name: SSGE-${VERSION}-windows.zip
          asset_content_type: application/zip

      - name: Upload release assets (Ubuntu)
        if: runner.os == 'Linux'
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }}
          asset_path: ./release/SSGE-${VERSION}-linux.tar.gz
          asset_name: SSGE-${VERSION}-linux.tar.gz
          asset_content_type: application/gzip
