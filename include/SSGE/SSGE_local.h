// This file should not be included
// It is used internally by the SSGE library

#ifndef __SSGE_LOCAL_H__
#define __SSGE_LOCAL_H__

#include <string.h>
#include <stdatomic.h>
#include "SSGE/SSGE_types.h"
#include "SSGE/SSGE_array.h"
#include "SSGE/SSGE_error.h"

#ifdef __cplusplus
extern "C" {
#endif

#define _PLAYING_ANIM_INITIAL_SIZE  64
#define _PLAYING_ANIM_GROWTH_FACTOR 2
#define _MAX_FRAMESKIP              3

typedef struct {
    int         x;
    int         y;
    uint16_t    width;
    uint16_t    height;
    SSGE_Flip   flip;
    SSGE_Point  rotationCenter;
    double      angle;
    bool        once;
} _SSGE_RenderData;


typedef struct {
    SSGE_Array          buffers[2];     // Double render buffer
    SDL_sem             *frameReady;
    SDL_sem             *frameConsummed;
    atomic_uintmax_t    framesGenerated; // Number of frames generated by update thread
    atomic_uintmax_t    framesRendered; // Number of frames consumed by the render thread
    atomic_uint_fast8_t writeBuffer;    // Index of the write buffer
    atomic_uint_fast8_t readBuffer;     // Index of the read buffer
    atomic_bool         evQueueBusy;    // If the event queue is busy
} _SSGE_DoubleRenderBuffer;

typedef struct {
    _SSGE_RenderData    *renderDatas;   // Array of render data
    SSGE_Texture        *texture;       // Texture pointer
    uint32_t            count;          // Number of renderData
} _SSGE_BufferedRenderItem;

typedef struct {
    SSGE_Event              queue[UINT8_MAX];
    atomic_uint_fast8_t     first;
    atomic_uint_fast8_t     last;
    atomic_uint_fast8_t     count;
} _SSGE_EventQueue;

typedef struct {
    void (*update)(void *);
    void (*eventHandler)(SSGE_Event, void *);
    void *data;
    _SSGE_DoubleRenderBuffer *doubleBuffer;
} _SSGE_UpdThreadData;

typedef struct {
    char                *title;
    struct SDL_Surface  *icon;
    uint16_t            width;
    uint16_t            height;
    bool                resizable;
    SSGE_WindowMode     fullscreen;
    bool                changed;
} _SSGE_WindowStateReq;

typedef void (*_SSGE_Destroy)(void *);

// Dummy type
typedef struct _DummyType {
    char *name;
    uint32_t id;
} DummyType;

extern SSGE_Engine  _engine;
extern SSGE_Array   _textureList;
extern SSGE_Array   _objectList;
extern SSGE_Array   _objectTemplateList;
extern SSGE_Array   _fontList;
extern SSGE_Array   _audioList;
extern SSGE_Array   _animationList;
extern SSGE_Array   _playingAnim;
extern SSGE_Color   _color;
extern SSGE_Color   _bgColor;
extern bool         _manualUpdateFrame;
extern bool         _updateFrame;

extern _SSGE_WindowStateReq _windowReq;
extern _SSGE_EventQueue     _evQueue;

#define _assert_engine_init \
if (!_engine.initialized) {\
    fprintf(stderr, "[SSGE][%s] Engine not initialized\n", __func__);\
    exit(1);\
}\

inline void _addToList(SSGE_Array *list, void *element, char *name, uint32_t *id, const char *funcname) {
    if (name) {
        ((DummyType *)element)->name = (char *)malloc(sizeof(char) * (strlen(name) + 1));
        if (((DummyType *)element)->name == NULL) {
            fprintf(stderr, "[SSGE][%s] Failed to allocate memory for name\n", funcname);
            exit(1);
        }
        strcpy(((DummyType *)element)->name, name);
    } else ((DummyType *)element)->name = NULL;

    if (id == NULL) {
        fprintf(stderr, "[SSGE][%s] ID is discarded\n", funcname);
        ((DummyType *)element)->id = SSGE_Array_Add(list, element);
        return;
    }
    *id = (((DummyType *)element)->id = SSGE_Array_Add(list, element));
}

inline void _initTextureFields(SSGE_Texture *texture) {
    texture->anchorX = 0;
    texture->anchorY = 0;

    atomic_init(&texture->refCount, 1);
    atomic_init(&texture->markedForDestroy, false);

    SSGE_Array_Create(&texture->queue);
}

inline void queueEvent(SSGE_Event event) {
    _evQueue.queue[atomic_fetch_add(&_evQueue.last, 1)] = event;
    atomic_fetch_add(&_evQueue.count, 1);
}

inline SSGE_Event popEvent() {
    atomic_fetch_sub(&_evQueue.count, 1);
    return _evQueue.queue[atomic_fetch_add(&_evQueue.first, 1)];
}

inline bool countEvent() {
    return atomic_load(&_evQueue.count);
}

void destroyTexture(SSGE_Texture *ptr);
void destroyObject(SSGE_Object *ptr);
void destroyTemplate(SSGE_ObjectTemplate *ptr);
void destroyFont(SSGE_Font *ptr);
void destroyAudio(SSGE_Audio *ptr);
void destroyAnimation(SSGE_Animation *ptr);

void textureAcquire(SSGE_Texture *texture);
void textureRelease(SSGE_Texture *texture);

void destroyBufferedRenderItem(void *ptr);

#ifdef __cplusplus
}
#endif

#endif // __SSGE_LOCAL_H__